#!/usr/bin/env bash

val_from_char() { local chr="$1"; LC_CTYPE=C; printf '%d' "'$chr"; }
char_from_val() { local -i val="$1"; printf $(printf "\\%03o" $val); }

# Simple implementation of a Yes/No prompt.
# Waits for either Y or N (either case), returning 0
# for 'Y' and 1 for 'N'.
get_yes_no()
{
    local keyp
    while true; do
        read -n1 -p"[Y]es or [N]o: " keyp
        if [ $? -eq 0 ]; then
            if [ "${keyp^^}" == "Y" ]; then
                echo
                return 0
            elif [ "${keyp^^}" == "N" ]; then
                echo
                return 1
            else
                echo -n "[2K[1G"  # erase line; move to leftmost (1) column
            fi
        fi
    done
}

# Waits for and returns single keypress, even if it is represented
# by multiple characters.
#
# This used to be the definitive get_keypress function, until I solved
# the ENTER key problem by using a *nameref* variable in which to return
# the detected keypress.  The *nameref* version is so much superior, I
# demoted this function to have the qualifier name (_echo).
get_keypress_echo()
{
    # IFS characters will be invisible to 'read', so:
    local IFS=''

    # Array to collect chars in case of multi-char keypress
    local -a chars=( )
    
    # Wait for a keypress (-n 1), save to array
    local keychar
    read -n 1 -s keychar
    chars=( "$keychar" )

    # Collect additional characters if available, especially for escape characters
    while read -t 0; do
        read -n 1 keychar
        chars=( "${chars[@]}" "$keychar" )
    done

    # empty IFS so array is joined without delimiters
    echo "${chars[*]}"
}

# This keypress function stores the array of characters
# to a named variable in order to preserve IFS characters.
get_keypress()
{
    # nameref var: using variable from caller's scope
    local -n charlist="$1"
    charlist=

    # IFS characters will be invisible to 'read', so:
    local IFS=''

    # read arguments:
    # -r  to force single characters (eschewing the backslash)
    # -N1 to force completion with first character
    # -s  silent: don't echo characters
    read  -srN1
    charlist="$REPLY"

    # Collect additional characters if available, especially for
    # escape characters.  Loops until `read` encounters an EOF.
    while read -t 0; do
        read -srN1
        charlist="${charlist[@]}$REPLY"
    done
}


# Call `keypress` alone on command line to test keypress results.
if ! ( return 0 2>/dev/null ); then
    echo "Keypress test mode.  Type any key to see the emitted character string."
    echo "Type 'q' to quit."
    declare keyp
    while [ 1 -eq 1 ]; do
        get_keypress "keyp"
        if [ "$keyp" == 'q' ]; then
            exit
        else
            echo "keypress was ${keyp///\\e}"
        fi
    done
fi

