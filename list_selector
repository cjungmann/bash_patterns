#!/usr/bin/env bash

source "keypress"

reset_screen() { echo -n "[2J[1;1H"; }

KEYPRESS_UP=$'\e[A'
KEYPRESS_DN=$'\e[B'
KEYPRESS_PGUP=$'\e[5~'
KEYPRESS_PGDN=$'\e[6~'

# Calculates the index of the first element to be displayed
# in the subset of the total array of elements.
# 
# Args:
#   (integer):    selected element index (out of complete array)
#   (integer):    current top (first element displayed)
#   (integer):    maximum number of elements to display
#   
# The value for $1 (selection) must be confirmed to be in range.
# It's more efficient to check when setting the value, and
# then we won't check for validity here.
calculate_top()
{
    local -i ct_selection="$1"
    local -i ct_top="$2"
    local -i ct_window="$3"

    local -i ct_last_index=$(( ct_top + ct_window - 1 ))
    local -i ct_new_top

    if [ "$ct_selection" -ge "$ct_top" ] && [ "$ct_selection" -lt "$ct_last_index" ]; then
        ct_new_top="$ct_top"
    elif [ "$ct_selection" -lt "$ct_top" ]; then
        ct_new_top="$ct_selection"
    elif [ "$ct_selection" -gt "$ct_last_index" ]; then
        local -i ct_trial_top=$(( ct_selection - ct_window + 1 ))
        if [ "$ct_trial_top" -lt 0 ]; then
            ct_new_top=0
        else
            ct_new_top="$ct_trial_top"
        fi
    else
        ct_new_top="$ct_top"
    fi

    echo "$ct_new_top"
}

# Calculates the number of elements to print for a given top index.
# Perhaps most times this will be the same as *count* ($2), but
# when scrolled down, there may be fewer than *count*, which this
# function calculates.
#
# Args:
#   (integer):   current top (first element displayed)
#   (integer):   number of elements in complete array
#   (integer):   maximum number of elements to display
#
# Output: integer value of last index value
calculate_last_index()
{
    local -i cl_top="$1"
    local -i cl_count="$2"
    local -i cl_window="$3"

    local -i cl_last_index=$(( cl_top + cl_window - 1  ))

    if [ "$cl_count" -lt "$cl_last_index" ]; then
        cl_last_index="$cl_count"
    fi

    echo "$cl_last_index"
}


# Default generic function used by select_from_list() to
# print each displayed list element.  
# Args:
#   (string):  name of triggering array
#   (integer): index of array element to be processed
#   (integer): selection flag, 0 if selected, non-zero if not selected
#
# Output
#   A single display line
generic_list_print_item()
{
    local -n gp_list="$1"
    local -i gp_index="$2"
    local -i gp_selected="${3:=0}"

    if [ "$gp_selected" -eq 0 ]; then
        echo -n "[32;1m"
    fi

    echo -n "generic_list_print_item: ${gp_list[$gp_index]}"
    echo "[m"
}

# Displays a list of array elements in which the user can select
# one of the elements by up- or down-arrow to move by one, or
# PgUp or PgDon to move up or down by a screen-full of elements.
# Escape or 'q' aborts, returning 1, ENTER echos the selection
# and return 0 (evaluates to TRUE for *test*).
#
# Args
#   (string):   name of variable into which the result will be stored
#   (string):   name of array of keys
#   (integer);  optional: number of elements to display at once (default 10)
#   (string):   optional: name of function that prints a list element
#
#   Additional arguments will be bundled to a new array and passed
#   to the printer function.
#   
# Output
#   If selection made, the selected index will be saved to the variable
#   referenced by the $1 argument.
select_from_list()
{
    local -n sfl_ndx_selected="$1"

    local sfl_name_of_array="$2"
    local -n sf_list="$sfl_name_of_array"
    local -i sfl_display_lines="${3:-10}"
    local sfl_item_printer="${4:-generic_list_print_item}"

    local -i sfl_items_count="${#sf_list[@]}"

    # $1 is the SECOND element of $@, so extra arguments start at index 5:
    local -a sfl_extra_arguments=( "${@:5}" )

    local -i sfl_ndx_top=0
    local -i sfl_last_index

    local sfl_keyp
    local -i sfl_ndx

    while : ; do
        reset_screen

        # Setup starting point and limits
        sfl_ndx_top=$( calculate_top "$sfl_ndx_selected" "$sfl_ndx_top" "$sfl_display_lines" )
        sfl_last_index=$( calculate_last_index "$sfl_ndx_top" "$sfl_items_count" "$sfl_display_lines" )

        for (( sfl_ndx=sfl_ndx_top; sfl_ndx<=sfl_last_index; ++sfl_ndx )); do
            local -a sfl_args=(
                "$sfl_name_of_array"
                "$sfl_ndx"
                $(( sfl_ndx_selected - sfl_ndx ))
                "${sfl_extra_arguments[@]}"
            )

            "$sfl_item_printer" "${sfl_args[@]}"
        done

        get_keypress "sfl_keyp"
        case "$sfl_keyp" in
            'q' | $'\e' )
                return 1
                ;;

            $'\n' )
                return 0
                ;;

            "$KEYPRESS_PGUP" )
                if [ "$sfl_ndx_selected" -gt "$sfl_ndx_top" ]; then
                    sfl_ndx_selected="$sfl_ndx_top"
                else
                    (( sfl_ndx_selected -= sfl_display_lines ))
                    if [ "$sfl_ndx_selected" -lt 0 ]; then
                        sfl_ndx_selected=0
                    fi
                fi
                ;;

            "$KEYPRESS_PGDN" )
                if [ "$sfl_ndx_selected" -lt "$sfl_last_index" ]; then
                    sfl_ndx_selected="$sfl_last_index"
                else
                    (( sfl_ndx_selected += sfl_display_lines ))
                    if [ "$sfl_ndx_selected" -gt "$sfl_items_count" ]; then
                        sfl_ndx_selected=$(( sfl_items_count-1 ))
                    fi
                fi
                ;;

            "$KEYPRESS_UP" )
                if [ "$sfl_ndx_selected" -gt 0 ]; then
                    (( --sfl_ndx_selected ))
                fi
                ;;

            "$KEYPRESS_DN" )
                if [ $(( sfl_ndx_selected+1 )) -lt "$sfl_items_count" ]; then
                    (( ++sfl_ndx_selected ))
                fi
                ;;
        esac
    done
}
