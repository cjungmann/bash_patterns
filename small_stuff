#!/usr/bin/env bash

# Clear screen, cursor to origin
reset_screen() { echo -n "[2J[1;1H"; }

hide_cursor() { echo -n $'\e[?25l'; }
show_cursor() { echo -n $'\e[?25h'; }

# Print string with ESCAPE and NEWLINE characters replaced by \e and \n
#
# Args
#    (string):   keystroke key
print_keystroke()
{
    local keyp="${1///\\e}"
    keyp="${keyp///\\n}"
    echo -n "$keyp"
}

# Function to duplicate a character a given number of times
# Args
#    (integer):   number of characters to repeat
#    (character): character to be repeated
# shellcheck disable=2155  # ignore 'declare and assign separately' warning
dupchar() { local s=$( printf "%0${1}d" 0 ); echo -n "${s//0/$2}"; }

# Get the current cursor position from the terminal, returning the
# values in nameref variables
# Args
#    (string):   name of rows variable
#    (string):   name of columns variable
get_cursor_position()
{
    local -n gcp_rows="$1"
    local -n gcp_cols="$2"

    local -a read_args=(
        -s          # silent mode
        -r          # don't escape backslash-prefixed characters
        -dR         # read until 'R' (expecting '\e[n;nR')
        -p $'\e[6n' # prompt, written to stdout, prompts terminal response
    )

    # set -x

    read "${read_args[@]}" REPLY

    IFS=';'
    local -a arr
    arr=( ${REPLY#*[} )

    local -i ecode
    local treply

    # discard any pending keypresses
    while read -t 0; ! (( ecode=$? )); do
        read -srN1
        treply="$REPLY"
    done

    gcp_rows="${arr[0]}"
    gcp_cols="${arr[1]}"

    # set +x
}

# Move the cursor to specified screen location
#
# Args
#    (integer):    row number
#    (integer):    column number
set_cursor_position()
{
    local -i row="${1:-1}"
    local -i col="${2:-1}"
    printf $'\e['"${row};${col}H"
}

block_print()
{
    local -i row="$1"
    local -i col="$2"
    local -i width="$3"
    local -n linearr="$4"

    local line spaces
    local -i padd

    set_cursor_position "$row" "$col"
    for line in "${linearr[@]}"; do
        (( pad = width - ${#line} ))
        if [ "$pad" -gt 0 ]; then
            spaces=$( dupchar "${pad}" ' ' )
            echo "${line}${spaces}"
        else
            echo "${line:0:$width}"
        fi

        echo -n $'\e['"${col}G"
    done
}


bp_test()
{
    local IFS=$'\n'
    local -a prose=(
        My mother told me to pick the best one
        and out goes you.  What do you think of that,
        you miserable lying cheat?  You are the worst
        one by far.
    )

    echo -n $'\e[44m'
    block_print 10 10 40 "prose"
    echo -n $'\e[m'
}

# bp_test

# Returns rows and columns size of screen in nameref variables
# 
# Args
#    (string):  name of variable for rows value
#    (string):  name of variable for columns value
get_screen_size()
{
    local -i csave rsave
    get_cursor_position "rsave" "csave"
    printf $'\e[999;999H'
    get_cursor_position "$1" "$2"
    printf $'\e['"${rsave};${csave}f"
}


# shellcheck disable=SC2046,SC2059  # quiet printf scolding

# The following two functions convert from character to an integer
# and back.

# Returns ASCII character when given an integer value.
char_from_val() { printf $(printf "\\%03o" "$1"); }
# Returns an integer value associated with an ASCII character
val_from_char() { LC_CTYPE=C; printf '%d' "'$1"; }


# Gets 0-based character position in first string of the first
# occurance of the second string
# Args
#   (string):    haystack, string to be searched
#   (string):    needle, substring to be sought in haystack
#
# Returns
#    echos integer position of needle in haystack
#    *true* if substring found
#    *false* if not found
strstrndx()
{
    local -i len1="${#1}"
    local sub="${1#*$2}"
    local -i sublen="${#sub}"
    if [ "$len1" -eq "$sublen" ]; then
        echo -1
        return 1
    fi

    echo $(( len1 - sublen - "${#2}" ))
    return 0
}

# This variable can be changed in a calling script to set a different default.
# Consult `man console_colors` for color-setting instructions.
declare SS_HILITE_COLOR="36;1"

# Find and hilite substring in string (if found)
# Args
#    (string):   string to print
#    (string):   substring for which the color should be changed
#    (string):   optional color string to use when coloring the substring
hilite_substr()
{
    local str="$1"
    local substr="$2"
    local color="${3:-$SS_HILITE_COLOR}"
    local -i pos
    if pos=$( strstrndx "$str", "$substr" ); then
        local -i lensub="${#substr}"

        echo -n "${str:0:$((pos))}"
        echo -n $'\e['"${color}m${substr}"$'\e[m'
        echo -n "${str:$((pos+lensub))}"
    fi
}

# Print a string, hilighting the character following the first
# underscore, and adding optionally padding to a requested length.
# Args
#    (string):    string to print
#    (integer):   total characters to print, with spaces filling
#                 positions unfilled with the string.  Negative
#                 values will pad to the left.
#    (string):    ANSI color string (without '\e[' prefix or 'm' suffix,
#                 they will be added when written out).
#                 NOTE: quote strings that include semicolons or the
#                 first semicolon will terminate the string.
hilite_pad()
{
    local str="$1"
    local -i pad="$2"
    local -i absolute_pad="${pad#-}"
    local -i len="${#1}"
    local color="${3:-$SS_HILITE_COLOR}"

    local -i pos
    if pos=$( strstrndx "$str" '_' ); then
        (( --len ))
        if [ "$pad" -lt 0 ]; then
            dupchar $(( absolute_pad - len )) ' '
        fi
        echo -n "${str:0:$((pos))}"
        echo -n $'\e7'                # save attributes and cursor position (mainly interested in color)
        echo -n $'\e['"${color}m"     # hilight color
        echo -n "${str:$((++pos)):1}" # hilighted character
        echo -n $'\e8\e[1C'           # restore saved stuff, advance cursor
        echo -n "${str:$((++pos))}"   # print remainder of string
    else
        if [ "$pad" -lt 0 ]; then
            dupchar $(( absolute_pad - len )) ' '
        fi
        echo -n "$str"
    fi

    if [ "$pad" -gt 0 ]; then
        dupchar $(( absolute_pad - len )) ' '
    fi
}

# 'Echo's the first character that follows the first
# underscore in the string and returns TRUE (0).
# If there is no underscore+character in the string,
# the function returns FALSE (!0)
# Args
#    (string):    string in which the letter following an underscore
#                 is sought and echoed.
get_hilite_char()
{
    local str="$1"
    local -i pos
    if pos=$( strstrndx "$str" '_' ); then
        echo "${str:$((pos+2)):1}"
        return 0
    else
        return 1
    fi
}


# Prints string exactly the length of $2.
#
# Short strings are supplemented with extra spaces,
# long strings are truncated.
#
# Args
#    (string)   string to be printed
#    (integer)  number of characters to print
force_length()
{
    local str="$1"
    local -i len="$2"

    local -i needed=$(( len - "${#str}" ))
    if [ "$needed" -gt 0 ]; then
        str="$str"$( dupchar "$needed" " " )
    else
        str="${str:0:$len}"
    fi

    echo -n "$str"
}


# Parses text to make an array of single-line paragraphs.
#
# Consecutive text lines will be combined into a single line, when a text line
# is separated from its neighbor by an empty line (i.e. two consecutive newlines),
# the next line will start a new paragraph.
#
# Use this function to prepare text for formatting in function format_paragraphs().
#
# The input of the function is *stdin*.  One way to use it could be:
#    local -a PARAS=()
#    bind_paragraphs "PARAS" < "text.txt"
#
# or:
#    local -a PARAS=()
#    bind_paragraphs "PARAS" <<EOF
#    Sample Text, paragraph 1
#
#    Sample Text, paragraph 2
#    EOF
#
# Args
#    (name):     name of array in which the comiled lines should be stored.
bind_paragraphs()
{
    local -n output="$1"
    output=()

    local datext
    local -a lines=()

    while IFS= read -r datext; do
        if [ -z "$datext" ]; then
            IFS=' '
            output+=( "${lines[*]}" )
            lines=()
        else
            lines+=( $datext )
        fi
    done

    IFS=' '
    output+=( "${lines[*]}" )
}

# Prints a line of text over as many lines as necessary.
#
# Args
#    (string):      The line/paragraph to be printed
#    (integer):     Number of characters allowed per line
#    (integer):     Number of characters to indent the first line
#                   of a paragraph
format_paragraph()
{
    local -a words=( $1 )
    local -i line_width="$2"
    local -i para_indent="$3"

    local indent=$( dupchar "$para_indent" ' ' )

    local word
    local -a line=( )
    local -i wordlen
    local -i linelen="$para_indent"

    for word in "${words[@]}"; do
        wordlen="${#word}"
        if [ "${#indent}" -gt 0 ]; then
            line=( "${indent}$word" )
            (( linelen = para_indent + wordlen ))
            indent=""
        elif (( wordlen + linelen >= line_width )); then
            echo "${line[*]}"
            line=( "$word" )
            (( linelen = wordlen ))
        else
            line+=( "$word" )
            (( linelen += wordlen + 1 ))
        fi
    done
    if [ "${#line[*]}" -gt 0 ]; then
        echo "${line[*]}"
    fi
}

# Sumbits text lines from an array to format_paragraph() to wrap lines
# as necessary to fit within the space limites.  Use this function on
# paragraph arrays prepared with bind_paragraphs().
#
# Args
#    (name):     name of array of paragraph strings
#    (integer):  number of characters permitted per line
#    (integer):  number of characters to indent the first line
#                of a paragraph.
format_paragraphs()
{
    local -n paras="$1"
    local -i width="${2:-50}"
    local -i para_indent="${3:-4}"

    local para
    for para in "${paras[@]}"; do
        format_paragraph "$para" "$width" "$para_indent"
    done
}




# declare -a PARAS

# bind_paragraphs "PARAS" <<EOF
# This is a paragraph that flows over several lines.  The mark of
# a new paragraph is at least two consecutive newlines.  Paragraphs bound
# will extend on a single line (no newlines), and can be of unlimited
# length.

# The purpose of these long lines of text is to ultimately break each
# paragraph into lines limited to a specific length.
# EOF

# format_paragraphs "PARAS" 60 2
# read -n1

# bind_paragraphs "PARAS" < small_stuff
# format_paragraphs "PARAS" 100 2
