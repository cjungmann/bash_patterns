#!/usr/bin/env bash

# The contents of this file work with a _lui_list_.  A lui_list is
# an array of data organized as a mini table.  The first element of
# a lui_list is the column count, the number of elements per 'row'
# of the lui_list table.  The second element is the row count, and
# it should be set with the lui_list_init() function.

# shellcheck disable=SC2178
# shellcheck disable=SC2034   # disable unused variable warning for nameref variable _rc_

declare LUI_KEY_UP=$'\e[A'
declare LUI_KEY_DN=$'\e[B'
declare LUI_KEY_PGUP=$'\e[5~'
declare LUI_KEY_PGDN=$'\e[6~'

# @def lui_list
# 
# A lui_list is a specially-formatted array that is used in the
# list_ui script to deliver list-based user interface patterns on
# a console.
#
# A lui_list consists of a two-integer prefix, whose values are
# the number of columns and the number of rows, followed by the
# data elements.  The data elements will be interpreted as each
# consecutive set of _columns_ elements is a row.  For example,
# a two-column lui_list would look like this:
# 
# declare -a my_list=(
#    2                      # columns
#    0                      # rows (calculated later)
#    row1_name row1_value
#    row2_name row2_value
#    row3_name row3_value
# )
#
# See also: lui_list_validate() Checks the array overall length against the
#                               column count value.
#           lui_list_init()     Updates the _rows_ element based on the column
#                               count and the total number of array elements.
#           lui_list_convert()  Makes a lui_list from another array.



# Test list dimensions
# Compare assumed row and column count to total array elements
# to identify likely valid lui_list.
# 
# Args
#    (name):    name of a lui_list
#
# Returns
#    true (0)       likely valid lui_list
#    false (1)      invalid lui_list
lui_list_validate()
{
    local -n llv_list="$1"
    local -i full_count="${#llv_list[@]}"
    if [ "$full_count" -lt 3 ]; then
        return 1
    fi

    local -i colcount="${llv_list[0]}"
    local -i rowcount="${llv_list[1]}"

    (( ((colcount * rowcount) + 2 ) == full_count ))
}

# Checks and updates row count of properly-constructed lui_list.
# 
# Sets the row-count element (list[1]) by calculating the number
# of rows.  A suspicious element count (not evenly-dividable by
# the column count) triggers a warning and exit.
# 
# Args
#    (name):   name of a properly formatted list
lui_list_init()
{
    local -n luii_list="$1"
    local -i columns="${luii_list[0]}"

    local -i count_els="${#luii_list[@]}"
    if [ $(( (count_els - 2) % columns )) -ne 0 ]; then
        echo "corrupted list, bad elements ratio." >&2
        exit 1
    fi

    luii_list[1]=$(( ( count_els - 2 ) / columns ))
    return 0
}

# Prepares properly-configured lui_list from a generic array.
#
# Submit an array to configure a properly-configured lui_list
# in the array named through argument 1.
#
# Args
#    (name):     array in which the derived lui_list will be written
#    (name):     array from which the lui_list will be created
#    (integer):  number of columns in the input array
#    (integer):  number of columns that should be in the output array
lui_list_convert()
{
    if [ "$1" == "$2" ]; then
        echo "Input and output lists must be different." >&2
        exit 1
    fi

    local -n llc_list_out="$1"
    local -n llc_list_in="$2"
    local -i in_cols="$3"
    local -i out_cols="$4"

    local -a extra_cols=()

    if [ "$out_cols" -gt "$in_cols" ]; then
        for (( i=0, limit=out_cols-in_cols; i<limit; ++i )); do
            extra_cols+=( 0 )
        done
    else
        out_cols="$in_cols"
    fi

    llc_list_out=( "$out_cols" 0 )
    local el
    local -a row=()
    local -i count=0
    for el in "${llc_list_in[@]}"; do
        row+=( "$el" )
        if [ "${#row[@]}" -eq "${in_cols}" ]; then
            (( ++count ))
            llc_list_out+=( "${row[@]}" "${extra_cols[@]}" )
            row=()
        fi
    done

    llc_list_out[1]="$count"
}

# @def list information functions
#
# This group of functions returns information about a lui_list

# Return column count value from lui_list
#
# Args
#    (name):    name of variable in which the result is returned
#    (name):    name of lui_list
lui_list_column_count() { local -n rc="$1"; local -n luil_list="$2"; rc="${luil_list[0]}"; }

# Return row count value from lui_list
#
# Args
#    (name):    name of variable in which the result is returned
#    (name):    name of lui_list
lui_list_row_count()    { local -n rc="$1"; local -n luil_list="$2"; rc="${luil_list[1]}"; }

# Test if requested row number exists in a lui_list
# 
# Args
#    (name):     name of lui list
#    (integer):  row number requested
#
# Returns true (0) if in range, non-zero if out of range
lui_list_row_in_range()
{
    local -n luii_list="$1"
    local -i requested_row="$2"
    local -i rows="${luii_list[1]}"

    [ "$requested_row" -ge 0 ] && [ "$requested_row" -lt "$rows" ]
}

# Sends successive rows to a callback function.  The callback function
# should return 0 (true) to continue, false (non-zero) to force early
# termination.
#
# Args
#    (name):   name of lui_list array
#    (name):   name of callback function
lui_list_iterate()
{
    local -i rows columns
    lui_list_row_count "rows" "$1"
    lui_list_column_count "columns" "$1"

    local -n luili_list="$1"
    local luili_callback="$2"

    for (( ndx=2, row=0; row<rows; ++row, ndx+=columns )); do
        if ! "$luili_callback" "${luili_list[@]:$ndx:$columns}"; then
            break
        fi
    done
}

# Clumsy name for a function that returns the characters in the longest# string
# in the given column for the given lui_list.
#
# Args
#    (name)  :  name of lui_list array
#    (integer): 0-based column number of column of interest
lui_list_max_len_by_column()
{
    local -i maxlen=0
    local -i requested_column="$2"
    max_len_callback()
    {
        # shellcheck disable=SC2124
        local val="${@:$(( requested_column+1 )):1}"
        local -i len="${#val}"
        if [ "$len" -gt "$maxlen" ]; then
            maxlen="$len"
        fi
    }

    lui_list_iterate "$1" "max_len_callback"
    unset max_len_callback

    echo "$maxlen"
}

# @def list row action functions
#
# Access the lui_list contents with row action functions.
# The 'get' function is lui_list_copy_row(), and
# the 'put' function is lui_list_replace_row().
#
# Despite having the same parameters, the parameter order
# is different for the two functions in order to maintain
# the library convention of keeping changing parameters
# leftmost.


# Get a row from a lui_list array.  Returns 0 (true) if the row
# was successfully returned, non-zero (false) if out-of-range and
# no row data is being returned.
# 
# Args
#    (name):     name of array in which the row is to be copied
#    (name):     name of lui_list array
#    (integer):  row number to be returned
lui_list_copy_row()
{
    if lui_list_row_in_range "$2" "$3"; then
        local -n target_row="$1"
        local -n luii_list="$2"
        local -i requested_row="$3"

        local -i columns="${luii_list[0]}"
        local -i rows="${luii_list[1]}"

        local -i ndx=$(( 2 + ( requested_row * columns ) ))
        target_row=( "${luii_list[@]:$ndx:$columns}" )
        return 0
    else
        echo "requested_row $3 is an out-of-range value for list '$2'" >&2
    fi

    return 1
}

# Get a row from a lui_list array.  Returns 0 (true) if the row
# was successfully returned, non-zero (false) if out-of-range and
# no row data is being returned.
# 
# Args
#    (name):     name of lui_list array
#    (name):     name of array from which the row is to be copied
#    (integer):  row number to be replaced
lui_list_replace_row()
{
    local list_name="$1"
    local -n luii_list="$list_name"
    local -n source_row="$2"
    local -i target_row_num="$3"

    if lui_list_row_in_range "$1" "$3"; then
        local -i columns="${luii_list[0]}"
        local -i rows="${luii_list[1]}"

        local -i ndx=$(( 2 + ( target_row_num * columns ) ))
        for (( i=0; i<columns; ++i )); do
            luii_list[$(( ndx + i ))]="${source_row[$i]}"
        done
        return 0
    else
        echo "requested_row $3 is an out-of-range value for list '$2'" >&2
    fi

    return 1
}

# @def line display functions
# 
# The lui_list_generic() requires a line display function.
# The line display function is called by lui_list_generic with three
# arguments for each line displayed on the screen:
# $1 (integer)    A flag parameter.  A non-zero value indicates that the row
#                 being displayed is the row on which any action will be
#                 taken, whether selection, toggle, or action.
# $2 (integer)    A padding value. It is the length of the longest of
#                 the first column elements, and can be used to ensure
#                 all list elements are the same length.
# ${@:2}          Parameters $3 and beyond are the elements of the
#                 selected row which can be used to 
#
# Built-in function lui_list_display_line() and lui_list_display_selectable_line()
# are models of line display functions.  Study them to better understand how
# line display functions work


# Model, minimal, default line displayer function.
#
# This function is called by lui_list_generic() for each line
# that is to be displayed.  It is expected that developers will
# create custom versions of this function for specific uses.
#
# The first argument is a flag indicating that the current row
# is the selected row.
#
# Args
#    (integer)     indicated flag, non-zero if active, zero if inactive
#    (integer)     minimum number of characters per line
#    (various...)  all elements of current row follow the second argument
lui_list_display_line()
{
    local -i hilite="$1"
    local -i padding="$2"
    local -a els=( "${@:3}" )

    if [ "$hilite" -ne 0 ]; then
        echo -n $'\e[44m'
    fi
    hilite_pad "${els[0]}" "$padding"
    echo $'\e[m'
}

# Model, minimal, default selectable line displayer
#
# This function is used by the built-in radio and checkbox
# dialogs derived from an appropriate lui_list.
#
# Args
#    (integer)     indicated flag, non-zero if active, zero if inactive
#    (integer)     minimum number of characters per line
#    (various...)  all elements of current row follow the second argument
lui_list_display_selectable_line()
{
    local -i hilite="$1"
    local -i padding="$2"
    local -a row=( "${@:3}" )
    if [ "$hilite" -ne 0 ]; then echo -n $'\e[43m'; fi
    if [ "${row[1]}" -eq 0 ]; then
        echo -n '[ ]'
    else
        echo -n '[x]'
    fi
    hilite_pad "${row[0]}" "$padding"
    echo $'\e[m'
}

# @def key action list
#
# A key action list is an array of function names, each associated with
# one or more keypress strings.  For each action, there is a list of
# keypress strings separated by the pipe character '|', followed by a
# function name, separated from the keypress strings with a colon ':'.
#
# A key action list is used by the function lui_list_process_key(),
# which in turn calls the key action function associated with a keypress
# string that matches the key just pressed by the user.
#
# Refer to 'key action functions' for details about how key action list
# functions are called.

declare -a LUI_DEFAULT_TERM_KEYS=(
    $'\e|q:LUI_ABORT'
    $'\n:LUI_SELECT'
    )

# @def key action functions
#
# These functions used by lui_list_generic() through a call to the
# function lui_list_process_key().  Even though an action may or may not
# target the indicated row, the lui_list and row number is passed to the
# key action function.
#
# When triggered, the key action function will receive the following
# parameters:
#
# $1 (string)          A character string representing the keypress that
#                      triggers this action
# $2 (name)            name of a lui_list that can be applied to a nameref
#                      variable to get access to the controlling lui_list.
# $3 (integer)         row number of the currently indicated row
# ${@:3} (various...)  optional extra parameters passed to lui_list_generic()
#                      following the first five parameters.
#
# The return value is unusual.  The following return values are significant:
#   0    the interaction continues
#   1    the interaction terminates with user aborting (ie ESC or 'q')
#   2    the interaction terminates with user mandate  (ie ENTER or space)
#
# Example row action functions are:
#   LUI_ABORT
#   LUI_SELECT
#   lui_list_action_radio_select
#   lui_list_action_checkbox_select


# Built-in term-keys function for ESC or 'q'
LUI_ABORT()  { return 1; }
# Built-in term-keys function for 'ENTER'
LUI_SELECT() { return 2; }

lui_list_action_radio_select()
{
    local keyp="$1"
    local list_name="$2"
    local -i row_ndx="$3"
    local -a extra=( "${@:3}" )

    local -n llar_list="$list_name"
    local -i row_count="${llar_list[1]}"
    local -a row
    for ((ndx=0; ndx < row_count; ++ndx )); do
        if lui_list_copy_row "row" "$list_name" "$ndx"; then
            if [ "$ndx" -eq "$row_ndx" ]; then
                (( row[1] = (row[1] + 1 ) % 2 ))
                lui_list_replace_row "$list_name" "row" "$ndx"
            elif [ "${row[1]}" -ne 0 ]; then
                (( row[1] = 0 ))
                lui_list_replace_row "$list_name" "row" "$ndx"
            fi
        else
            echo "radio select row out-of-range" >&2
            exit 1
        fi
    done

    return 0
}

lui_list_action_checkbox_select()
{
    local keyp="$1"
    local list_name="$2"
    local -i row_ndx="$3"
    local -a extra=( "${@:3}" )

    local -a row
    if lui_list_copy_row "row" "$list_name" "$row_ndx"; then
        (( row[1] = (row[1] + 1 ) % 2 ))
        lui_list_replace_row "$list_name" "row" "$row_ndx"
    else
        echo "radio select row out-of-range" >&2
        exit 1
    fi

    return 0
}

# @def lui_list display functions
#
# There are several functions that manage the display and navigation
# of a lui_list.


# Internal function processes selection keypresses for lui_list_generic().
#
# Args
#    (string):   string representing a keypress
#    (integer):  index of currently-selected list element
#    (integer):  index of top/first element displayed on screen
#    (integer):  maximum number of lines to display
#    (integer):  number of elements in the lui_list
lui_list_key_move_selection()
{
    local keyp="$1"
    local -i selected="$2"
    local -i top_row="$3"
    local -i line_count="$4"
    local -i row_count="$5"

    local -i bottom_row=$(( top_row + line_count - 1 ))
    local -i matched=0

    case "$keyp" in
        "$LUI_KEY_DN" )
            (( ++selected, ++matched ))
            if [ "$selected" -ge "$row_count"  ]; then
                selected=$(( row_count-1 ))
            fi
            ;;
        "$LUI_KEY_UP" )
            (( --selected, ++matched ))
            if [ "$selected" -lt 0 ]; then
                selected=0
            fi
            ;;
        "$LUI_KEY_PGUP" )
            (( ++matched ))
            if [ "$selected" -eq "$top_row" ]; then
                selected=$(( selected - line_count ))
            else
                selected="$top_row"
            fi
            if [ "$selected" -lt 0 ]; then
                selected=0
            fi
            ;;
        "$LUI_KEY_PGDN" )
            (( ++matched ))
            if [ "$selected" -eq "$bottom_row" ]; then
                selected=$(( selected + line_count ))
            else
                selected="$bottom_row"
            fi
            if [ "$selected" -ge "$row_count" ]; then
                selected=$(( row_count - 1 ))
            fi
            ;;
    esac

    echo "$selected"
    [ "$matched" -gt 0 ]
}

# Used by lui_list_generic() to discern the top/first display row.
#
# Args
#    (integer):    index in full list of currently selected item
#    (integer):    top row before calculation
#    (integer):    maximum number of items displayed on screen
lui_list_calc_top_row()
{
    local -i selected="$1"
    local -i top_row="$2"
    local -i line_count="$3"
    if [ "$selected" -lt "$top_row" ]; then
        echo "$selected"
    elif [ "$selected" -gt $(( top_row + line_count - 1 )) ]; then
        echo $(( selected - line_count + 1 ))
    else
        echo "$top_row"
    fi
}

# Display a screen-full of list items.
#
# This function prints out a screenful of item lines based on various
# list and index metrics.
#
# Args
#    (name):      name of lui_list that provides content for display
#    (integer):   index of selected item
#    (integer):   index of first item to display
#    (integer):   number of lines to display
#    (name):      name of function that should be used to display lines
#    (integer):   minimum number of characters to print per item
lui_list_show_lines()
{
    local lui_list_name="$1"
    local -i selected="$2"
    local -i top_row="$3"
    local -i line_count="$4"
    local line_displayer="$5"
    local -i padding="${6:-0}"

    local -a row
    local -i count=0
    local -i row_ndx="$top_row"
    local -i hilited

    for (( ; count < line_count; ++count, ++row_ndx )); do
        row=()
        if [ "$row_ndx" -lt "$row_count" ]; then

            # Convert boolean result to integer for use by line_displayer:
            [ "$row_ndx" -ne "$selected" ]
            hilited="$?"

            lui_list_copy_row "row" "$lui_list_name" "$row_ndx"
            "$line_displayer" "$hilited" "$padding" "${row[@]}"
        else
            hilite_pad " " "$padding"
            echo
        fi
    done
}


# Process a key array, calling a function according to matched keys.
#
# Args
#    (string):     string representation of a keypress
#    (name):       name of a key array
#    (name):       name of lui_list in use
#    (integer):    index into the lui_list of the indicated item
#    (various):    extra arguments passed to lui_list_generic(),
#                  that is $6 and above
#
# Returns 0 if no key matched, 1 to terminate 
lui_list_process_key()
{
    local keyp="$1"
    local -n key_arr="$2"
    local list_name="$3"
    local -i row_number="$4"
    local -a extra_args=( "${@:5}" )

    local -a entry keys
    local k IFS key cmd
    # shellcheck disable=SC2206  # don't warn for unquoted variable array initialization
    for k in "${key_arr[@]}"; do
        IFS=':'; entry=( $k )
        IFS="|"; keys=( ${entry[0]} )
        cmd="${entry[1]}"

        for key in "${keys[@]}"; do
            if [ "$key" == "$keyp" ]; then
                "$cmd" "$keyp" "$list_name" "$row_number" "${extra_args[@]}"
                return "$?"
            fi
        done
    done

    # zero return value means that we didn't match the key
    return 0
}

# @def primary list interaction
#
# The function lui_list_generic() is the simple and flexible consolidation
# of the list display, navigation, and general keypress functions described
# above.  Other interactions will call lui_list_generic() with custom
# line display functions and key action lists.

# Creates lui_list-based UI widgets
#
# Nearly any list-based user interaction can be build using this function
# by providing custom line display and key list definitions.
#
# Args
#    (name):       name of integer variable in which the selected index will be put
#    (name):       name of lui_list from which the widget will be constructed
#    (name):       name of function that will display summary lines
#    (integer):    number of lines to display per 'screenful'
#    (name):       name of keystroke functions list
#    (various...): Optional extra arguments that will be passed to keystroke functions.
#                  These extra arguments can be exploited by custom widgets.
lui_list_generic()
{
    # shellcheck disable=SC2155
    local -n llg_selected="$1"
    local lui_list_name="$2"
    local line_displayer="${3:-lui_list_display_line}"
    local -i line_count="${4:-10}"
    local term_keys_list_name="${5:-LUI_DEFAULT_TERM_KEYS}"
    local -a extra_args=( "${@:6}" )

    if [ "$line_count" -lt 2 ]; then
        echo "Invalid line count: $line_count" >&2
        exit 1
    fi

    local -i row_count
    lui_list_row_count "row_count" "$lui_list_name"

    local -i padding
    padding=$( lui_list_max_len_by_column "$lui_list_name" 0 )

    local -i top_row
    local -a row
    local -a key_args proc_args
    local keyp
    local -i key_proc_exit

    top_row=1
    while : ; do
        top_row=$( lui_list_calc_top_row "$llg_selected" "$top_row" "$line_count" )

        reset_screen
        hide_cursor
        lui_list_show_lines "$lui_list_name" "$llg_selected" "$top_row" \
                             "$line_count" "$line_displayer" "$padding"
        show_cursor

        if get_keypress "keyp"; then
            key_args=( "$keyp" "$llg_selected" "$top_row" "$line_count" "$row_count" )
            if ! llg_selected=$( lui_list_key_move_selection "${key_args[@]}" ); then
                proc_args=( "$keyp" "$term_keys_list_name" "$lui_list_name" "$llg_selected" )
                lui_list_process_key "${proc_args[@]}" "${extra_args[@]}"
                key_proc_exit="$?"
                if [ "$key_proc_exit" -gt 1 ]; then
                    return 0
                elif [ "$key_proc_exit" -gt 0 ]; then
                    return 1
                fi
            fi
        fi
    done
}

# @def specific list interaction types
#
# There are several simple interactions types that call lui_list_generic().
# These functions perform their basic duties, but also serve as examples
# of proper usage of lui_list_generic() for custom tasks.

lui_list_menu()
{
    local llm_selected_name="$1"
    local llm_list_name="$2"
    local -i line_count="${3:-10}"

    lui_list_generic "$llm_selected_name" "$llm_list_name" "" "$line_count"
}

lui_list_radio()
{
    if ! lui_list_validate "$1"; then
        echo "Invalid lui_list submited to lui_list_radio." >&2
        exit 1
    fi

    local llr_list_name="$1"
    local -i lines="${2:-10}"
    local -i selected=0

    local -a keylist=(
        "${LUI_DEFAULT_TERM_KEYS[@]}"
        $' :lui_list_action_radio_select'
    )

    lui_list_generic "selected" "$llr_list_name" "lui_list_display_selectable_line" "$lines" "keylist"
}

lui_list_checkbox()
{
    if ! lui_list_validate "$1"; then
        echo "Invalid lui_list submited to lui_list_checkbox." >&2
        exit 1
    fi

    local llr_list_name="$1"
    local -i lines="${2:-10}"
    local -i selected=0

    local -a keylist=(
        "${LUI_DEFAULT_TERM_KEYS[@]}"
        $' :lui_list_action_checkbox_select'
    )

    lui_list_generic "selected" "$llr_list_name" "lui_list_display_selectable_line" "$lines" "keylist"
}

