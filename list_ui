#!/usr/bin/env bash

# The contents of this file work with a _lui_list_.  A lui_list is
# an array of data organized as a mini table.  The first element of
# a lui_list is the column count, the number of elements per 'row'
# of the lui_list table.  The second element is the row count, and
# it should be set with the lui_list_init() function.

# shellcheck disable=SC2178
# shellcheck disable=SC2034   # disable unused variable warning for nameref variable _rc_ 

declare LUI_KEY_UP=$'\e[A'
declare LUI_KEY_DN=$'\e[B'
declare LUI_KEY_PGUP=$'\e[5~'
declare LUI_KEY_PGDN=$'\e[6~'

# Sets the row-count element (list[1]) by calculating the number
# of rows.  A suspicious element count (not evenly-dividable by
# the column count) triggers a warning and exit.
# Args
#    (string):   name of a properly formatted list
lui_list_init()
{
    local -n luii_list="$1"
    local -i columns="${luii_list[0]}"

    local -i count_els="${#luii_list[@]}"
    if [ $(( (count_els - 2) % columns )) -ne 0 ]; then
        echo "corrupted list, bad elements ratio." >&2
        exit
    fi
    
    luii_list[1]=$(( ( count_els - 2 ) / columns ))
    return 0
}

# Next two functions put result in nameref-ed first argument
lui_list_column_count() { local -n rc="$1"; local -n luil_list="$2"; rc="${luil_list[0]}"; }
lui_list_row_count()    { local -n rc="$1"; local -n luil_list="$2"; rc="${luil_list[1]}"; }

# Test if requested row number exists in a lui_list
# Args
#    (string):   name of lui list
#    (integer):  row number requested
#
# Returns true (0) if in range, non-zero if out of range
lui_list_row_in_range()
{
    local -n luii_list="$1"
    local -i requested_row="$2"
    local -i rows="${luii_list[1]}"

    [ "$requested_row" -ge 0 ] && [ "$requested_row" -lt "$rows" ]
}

# Sends successive rows to a callback function.  The callback function
# should return 0 (true) to continue, false (non-zero) to force early
# termination.
# 
# Args
#    (string):   name of lui_list array
#    (string):   name of callback function
lui_list_iterate()
{
    local -i rows columns
    lui_list_row_count "rows" "$1"
    lui_list_column_count "columns" "$1"

    local -n luili_list="$1"
    local luili_callback="$2"

    for (( ndx=2, row=0; row<rows; ++row, ndx+=columns )); do
        if ! "$luili_callback" "${luili_list[@]:$ndx:$columns}"; then
            break
        fi
    done
}

# Get a row from a lui_list array.  Returns 0 (true) if the row
# was successfully returned, non-zero (false) if out-of-range and
# no row data is being returned.
# Args
#    (string):   name of array in which the row is to be copied
#    (string):   name of lui_list array
#    (integer):  row number to be returned
lui_list_copy_row()
{
    if lui_list_row_in_range "$2" "$3"; then
        local -n target_row="$1"
        local -n luii_list="$2"
        local -i requested_row="$3"

        local -i columns="${luii_list[0]}"
        local -i rows="${luii_list[1]}"

        local -i ndx=$(( 2 + ( requested_row * columns ) ))
        target_row=( "${luii_list[@]:$ndx:$columns}" )
        return 0
    fi

    return 1
}

# Clumsy name for a function that returns the characters in the longest
# string in the given column for the given lui_list.
# Args
#    (string):  name of lui_list array
#    (integer): 0-based column number of column of interest
lui_list_max_len_by_column()
{
    local -i maxlen=0
    local -i requested_column="$2"
    max_len_callback()
    {
        # shellcheck disable=SC2124
        local val="${@:$(( requested_column+1 )):1}"
        local -i len="${#val}"
        if [ "$len" -gt "$maxlen" ]; then
            maxlen="$len"
        fi
    }

    lui_list_iterate "$1" "max_len_callback"
    unset max_len_callback

    echo "$maxlen"
}

lui_list_menu_display_line()
{
    local -i hilite="$1"
    local -i padding="$2"
    local -a els=( "${@:3}" )

    if [ "$hilite" -ne 0 ]; then
        echo -n $'\e[44m'
    fi
    hilite_pad "${els[0]}" "$padding"
    echo $'\e[m'
}

lui_list_key_move_selection()
{
    local keyp="$1"
    local -i selected="$2"
    local -i row_count="$3"
    local -i line_count="$4"
    local -i top_row="$5"
    local -i bottom_row="$6"

    local -i old_selected="$2"

    case "$keyp" in
        "$LUI_KEY_DN" )
            (( ++selected ))
            if [ "$selected" -ge "$row_count"  ]; then
                selected=$(( row_count-1 ))
            fi
            ;;
        "$LUI_KEY_UP" )
            (( --selected ))
            if [ "$selected" -lt 0 ]; then
                selected=0
            fi
            ;;
        "$LUI_KEY_PGUP" )
            if [ "$selected" -eq "$top_row" ]; then
                selected=$(( selected - line_count ))
            else
                selected="$top_row"
            fi
            if [ "$selected" -lt 0 ]; then
                selected=0
            fi
            ;;
        "$LUI_KEY_PGDN" )
            if [ "$selected" -eq "$bottom_row" ]; then
                selected=$(( selected + line_count ))
            else
                selected="$bottom_row"
            fi
            if [ "$selected" -ge "$row_count" ]; then
                selected=$(( row_count - 1 ))
            fi
            ;;
    esac

    echo "$selected"
    [ "$selected" -ne "$old_selected" ]
}

lui_list_menu()
{
    local lui_list_name="$1"
    local line_displayer="${2:-lui_list_menu_display_line}"
    local -i line_count="${3:-10}"

    local -i row_count
    lui_list_row_count "row_count" "$lui_list_name"

    local -i padding=$( lui_list_max_len_by_column "$lui_list_name" 0 )

    local -i selected=0
    local -i top_row bottom_row
    local -a row

    top_row=1 # triggers first condition to preempt elif with uninitialized $bottom_row
    while : ; do
        if [ "$selected" -lt "$top_row" ]; then
            top_row="$selected"
        elif [ "$selected" -gt "$bottom_row" ]; then
            top_row=$(( selected - line_count + 1 ))
        fi
        
        bottom_row=$(( top_row + line_count - 1 ))
        
        reset_screen
        hide_cursor
        for (( count=0, row_ndx=top_row; count<line_count; ++count, ++row_ndx )); do
            row=()
            if [ "$row_ndx" -lt "$row_count" ]; then
                [ "$row_ndx" -ne "$selected" ]
                hilited="$?"
                # shellcheck disable=SC2207
                lui_list_copy_row "row" "$lui_list_name" "$row_ndx"
                "$line_displayer" "$hilited" "$padding" "${row[@]}"
            else
                hilite_pad " " "$padding"
                echo
            fi
        done
        show_cursor

        local keyp

        if get_keypress "keyp"; then
            case "$keyp" in
                $'\e'|'q' ) return 1 ;;
                $'\n'     ) return 0 ;;
                * )
                    move_args=("$keyp" "$selected"
                        "$row_count" "$line_count"
                        "$top_row" "$bottom_row" )
                    local -i old_selected=$selected
                    selected=$( lui_list_key_move_selection "${move_args[@]}" )
                    ;;
            esac
        fi
    done
}

