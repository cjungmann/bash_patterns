#!/usr/bin/env bash

# The contents of this file work with a _lui_list_.  A lui_list is
# an array of data organized as a mini table.  The first element of
# a lui_list is the column count, the number of elements per 'row'
# of the lui_list table.  The second element is the row count, and
# it should be set with the lui_list_init() function.

# @def lui_list
# 
# A lui_list is a specially-formatted array that is used in the
# list_ui script to deliver list-based user interface patterns on
# a console.
#
# A lui_list consists of a two-integer prefix, whose values are
# the number of columns and the number of rows, followed by the
# data elements.  The data elements will be interpreted as each
# consecutive set of _columns_ elements is a row.  For example,
# a two-column lui_list would look like this:
# 
# declare -a my_list=(
#    2                      # columns
#    0                      # rows (calculated later)
#    row1_name row1_value
#    row2_name row2_value
#    row3_name row3_value
# )
#
# See also: lui_list_init() to update the _rows_ element,
#           lui_list_convert() to make a lui_list from another array



# shellcheck disable=SC2178
# shellcheck disable=SC2034   # disable unused variable warning for nameref variable _rc_

declare LUI_KEY_UP=$'\e[A'
declare LUI_KEY_DN=$'\e[B'
declare LUI_KEY_PGUP=$'\e[5~'
declare LUI_KEY_PGDN=$'\e[6~'

# Built-in term-keys function for ESC or 'q'
LUI_ABORT()  { return 1; }
# Built-in term-keys function for 'ENTER'
LUI_SELECT() { return 2; }

declare -a LUI_DEFAULT_TERM_KEYS=(
    $'\e'"|q:LUI_ABORT"
    $'\n'":LUI_SELECT"
    )

# Checks and updates row count of properly-constructed lui_list.
# 
# Sets the row-count element (list[1]) by calculating the number
# of rows.  A suspicious element count (not evenly-dividable by
# the column count) triggers a warning and exit.
# 
# Args
#    (name):   name of a properly formatted list
lui_list_init()
{
    local -n luii_list="$1"
    local -i columns="${luii_list[0]}"

    local -i count_els="${#luii_list[@]}"
    if [ $(( (count_els - 2) % columns )) -ne 0 ]; then
        echo "corrupted list, bad elements ratio." >&2
        exit 1
    fi

    luii_list[1]=$(( ( count_els - 2 ) / columns ))
    return 0
}

# Prepares properly-configured lui_list from a generic array.
#
# Submit an array to configure a properly-configured lui_list
# in the array named through argument 1.
#
# Args
#    (name):     array in which the derived lui_list will be written
#    (name):     array from which the lui_list will be created
#    (integer):  number of columns in the input array
#    (integer):  number of columns that should be in the output array
lui_list_convert()
{
    if [ "$1" == "$2" ]; then
        echo "Input and output lists must be different." >&2
        exit 1
    fi

    local -n llc_list_out="$1"
    local -n llc_list_in="$2"
    local -i in_cols="$3"
    local -i out_cols="$4"

    local -a extra_cols=()

    if [ "$out_cols" -gt "$in_cols" ]; then
        for (( i=0, limit=out_cols-in_cols; i<limit; ++i )); do
            extra_cols+=( 0 )
        done
    else
        out_cols="$in_cols"
    fi

    llc_list_out=( "$out_cols" 0 )
    local el
    local -a row=()
    local -i count=0
    for el in "${llc_list_in[@]}"; do
        row+=( "$el" )
        if [ "${#row[@]}" -eq "${in_cols}" ]; then
            (( ++count ))
            llc_list_out+=( "${row[@]}" "${extra_cols[@]}" )
            row=()
        fi
    done

    llc_list_out[1]="$count"
}

# Return column count value from lui_list
#
# Args
#    (name):    name of variable in which the result is returned
#    (name):    name of lui_list
lui_list_column_count() { local -n rc="$1"; local -n luil_list="$2"; rc="${luil_list[0]}"; }

# Return row count value from lui_list
#
# Args
#    (name):    name of variable in which the result is returned
#    (name):    name of lui_list
lui_list_row_count()    { local -n rc="$1"; local -n luil_list="$2"; rc="${luil_list[1]}"; }

# Test if requested row number exists in a lui_list
# 
# Args
#    (name):     name of lui list
#    (integer):  row number requested
#
# Returns true (0) if in range, non-zero if out of range
lui_list_row_in_range()
{
    local -n luii_list="$1"
    local -i requested_row="$2"
    local -i rows="${luii_list[1]}"

    [ "$requested_row" -ge 0 ] && [ "$requested_row" -lt "$rows" ]
}

# Sends successive rows to a callback function.  The callback function
# should return 0 (true) to continue, false (non-zero) to force early
# termination.
#
# Args
#    (name):   name of lui_list array
#    (name):   name of callback function
lui_list_iterate()
{
    local -i rows columns
    lui_list_row_count "rows" "$1"
    lui_list_column_count "columns" "$1"

    local -n luili_list="$1"
    local luili_callback="$2"

    for (( ndx=2, row=0; row<rows; ++row, ndx+=columns )); do
        if ! "$luili_callback" "${luili_list[@]:$ndx:$columns}"; then
            break
        fi
    done
}

# Get a row from a lui_list array.  Returns 0 (true) if the row
# was successfully returned, non-zero (false) if out-of-range and
# no row data is being returned.
# 
# Args
#    (name):     name of array in which the row is to be copied
#    (name):     name of lui_list array
#    (integer):  row number to be returned
lui_list_copy_row()
{
    if lui_list_row_in_range "$2" "$3"; then
        local -n target_row="$1"
        local -n luii_list="$2"
        local -i requested_row="$3"

        local -i columns="${luii_list[0]}"
        local -i rows="${luii_list[1]}"

        local -i ndx=$(( 2 + ( requested_row * columns ) ))
        target_row=( "${luii_list[@]:$ndx:$columns}" )
        return 0
    else
        echo "requested_row $3 is an out-of-range value for list '$2'" >&2
    fi

    return 1
}

# Get a row from a lui_list array.  Returns 0 (true) if the row
# was successfully returned, non-zero (false) if out-of-range and
# no row data is being returned.
# 
# Args
#    (name):     name of lui_list array
#    (name):     name of array from which the row is to be copied
#    (integer):  row number to be replaced
lui_list_replace_row()
{
    local list_name="$1"
    local -n luii_list="$list_name"
    local -n source_row="$2"
    local -i target_row_num="$3"

    if lui_list_row_in_range "$1" "$3"; then
        local -i columns="${luii_list[0]}"
        local -i rows="${luii_list[1]}"

        local -i ndx=$(( 2 + ( target_row_num * columns ) ))
        for (( i=0; i<columns; ++i )); do
            luii_list[$(( ndx + i ))]="${source_row[$i]}"
        done
        return 0
    else
        echo "requested_row $3 is an out-of-range value for list '$2'" >&2
    fi

    return 1
}

# Clumsy name for a function that returns the characters in the longest# string
# in the given column for the given lui_list.
#
# Args
#    (name)  :  name of lui_list array
#    (integer): 0-based column number of column of interest
lui_list_max_len_by_column()
{
    local -i maxlen=0
    local -i requested_column="$2"
    max_len_callback()
    {
        # shellcheck disable=SC2124
        local val="${@:$(( requested_column+1 )):1}"
        local -i len="${#val}"
        if [ "$len" -gt "$maxlen" ]; then
            maxlen="$len"
        fi
    }

    lui_list_iterate "$1" "max_len_callback"
    unset max_len_callback

    echo "$maxlen"
}

# Model, minimal, default line displayer function.
#
# This function is called by lui_list_generic() for each line
# that is to be displayed.  It is expected that developers will
# create custom versions of this function for specific uses.
#
# The first argument is a flag indicating that the current row
# is the selected row.
#
# Args
#    (integer):    hilight line if value is non-zero
#    (integer):    minimum number of characters per line
#    (various):    all elements of current row follow the second argument
lui_list_display_line()
{
    local -i hilite="$1"
    local -i padding="$2"
    local -a els=( "${@:3}" )

    if [ "$hilite" -ne 0 ]; then
        echo -n $'\e[44m'
    fi
    hilite_pad "${els[0]}" "$padding"
    echo $'\e[m'
}

# Internal function processes selection keypresses for lui_list_generic().
#
# Args
#    (string):   string representing a keypress
#    (integer):  index of currently-selected list element
#    (integer):  index of top/first element displayed on screen
#    (integer):  maximum number of lines to display
#    (integer):  number of elements in the lui_list
lui_list_key_move_selection()
{
    local keyp="$1"
    local -i selected="$2"
    local -i top_row="$3"
    local -i line_count="$4"
    local -i row_count="$5"

    local -i bottom_row=$(( top_row + line_count - 1 ))
    local -i matched=0

    case "$keyp" in
        "$LUI_KEY_DN" )
            (( ++selected, ++matched ))
            if [ "$selected" -ge "$row_count"  ]; then
                selected=$(( row_count-1 ))
            fi
            ;;
        "$LUI_KEY_UP" )
            (( --selected, ++matched ))
            if [ "$selected" -lt 0 ]; then
                selected=0
            fi
            ;;
        "$LUI_KEY_PGUP" )
            (( ++matched ))
            if [ "$selected" -eq "$top_row" ]; then
                selected=$(( selected - line_count ))
            else
                selected="$top_row"
            fi
            if [ "$selected" -lt 0 ]; then
                selected=0
            fi
            ;;
        "$LUI_KEY_PGDN" )
            (( ++matched ))
            if [ "$selected" -eq "$bottom_row" ]; then
                selected=$(( selected + line_count ))
            else
                selected="$bottom_row"
            fi
            if [ "$selected" -ge "$row_count" ]; then
                selected=$(( row_count - 1 ))
            fi
            ;;
    esac

    echo "$selected"
    [ "$matched" -gt 0 ]
}

# Used by lui_list_generic() to discern the top/first display row.
#
# Args
#    (integer):    index in full list of currently selected item
#    (integer):    top row before calculation
#    (integer):    maximum number of items displayed on screen
lui_list_calc_top_row()
{
    local -i selected="$1"
    local -i top_row="$2"
    local -i line_count="$3"
    if [ "$selected" -lt "$top_row" ]; then
        echo "$selected"
    elif [ "$selected" -gt $(( top_row + line_count - 1 )) ]; then
        echo $(( selected - line_count + 1 ))
    else
        echo "$top_row"
    fi
}

# Display a screen-full of list items.
#
# This function prints out a screenful of item lines based on various
# list and index metrics.
#
# Args
#    (name):      name of lui_list that provides content for display
#    (integer):   index of selected item
#    (integer):   index of first item to display
#    (integer):   number of lines to display
#    (name):      name of function that should be used to display lines
#    (integer):   minimum number of characters to print per item
lui_list_show_lines()
{
    local lui_list_name="$1"
    local -i selected="$2"
    local -i top_row="$3"
    local -i line_count="$4"
    local line_displayer="$5"
    local -i padding="${6:-0}"

    local -a row
    local -i count=0
    local -i row_ndx="$top_row"
    local -i hilited

    for (( ; count < line_count; ++count, ++row_ndx )); do
        row=()
        if [ "$row_ndx" -lt "$row_count" ]; then

            # Convert boolean result to integer for use by line_displayer:
            [ "$row_ndx" -ne "$selected" ]
            hilited="$?"

            lui_list_copy_row "row" "$lui_list_name" "$row_ndx"
            "$line_displayer" "$hilited" "$padding" "${row[@]}"
        else
            hilite_pad " " "$padding"
            echo
        fi
    done
}


# Process a key array, calling a function according to matched keys.
#
# Args
#    (string):     string representation of a keypress
#    (name):       name of a key array
#    (name):       name of lui_list in use
#    (integer):    index into the lui_list of the indicated item
#    (various):    extra arguments passed to lui_list_generic(),
#                  that is $6 and above
#
# Returns 0 if no key matched, 1 to terminate 
lui_list_process_key()
{
    local keyp="$1"
    local -n key_arr="$2"
    local list_name="$3"
    local -i row_number="$4"
    local -a extra_args=( "${@:5}" )

    local -a entry keys
    local k IFS key cmd
    # shellcheck disable=SC2206  # don't warn for unquoted variable array initialization
    for k in "${key_arr[@]}"; do
        IFS=':'; entry=( $k )
        IFS="|"; keys=( ${entry[0]} )
        cmd="${entry[1]}"

        for key in "${keys[@]}"; do
            if [ "$key" == "$keyp" ]; then
                "$cmd" "$keyp" "$list_name" "$row_number" "${extra_args[@]}"
                return "$?"
            fi
        done
    done

    # zero return value means that we didn't match the key
    return 0
}

# Creates lui_list-based UI widgets
#
# Nearly any list-based user interaction can be build using this function
# by providing custom line display and key list definitions.
#
# Args
#    (name):       name of integer variable in which the selected index will be put
#    (name):       name of lui_list from which the widget will be constructed
#    (name):       name of function that will display summary lines
#    (integer):    number of lines to display per 'screenful'
#    (name):       name of keystroke functions list
#    (various...): Optional extra arguments that will be passed to keystroke functions.
#                  These extra arguments can be exploited by custom widgets.
lui_list_generic()
{
    # shellcheck disable=SC2155
    local -n llg_selected="$1"
    local lui_list_name="$2"
    local line_displayer="${3:-lui_list_display_line}"
    local -i line_count="${4:-10}"
    local term_keys_list_name="${5:-LUI_DEFAULT_TERM_KEYS}"
    local -a extra_args=( "${@:6}" )

    local -i row_count
    lui_list_row_count "row_count" "$lui_list_name"

    local -i padding
    padding=$( lui_list_max_len_by_column "$lui_list_name" 0 )

    local -i top_row
    local -a row
    local -a key_args proc_args
    local keyp
    local -i key_proc_exit

    top_row=1
    while : ; do
        top_row=$( lui_list_calc_top_row "$llg_selected" "$top_row" "$line_count" )

        reset_screen
        hide_cursor
        lui_list_show_lines "$lui_list_name" "$llg_selected" "$top_row" \
                             "$line_count" "$line_displayer" "$padding"
        show_cursor

        if get_keypress "keyp"; then
            key_args=( "$keyp" "$llg_selected" "$top_row" "$line_count" "$row_count" )
            if ! llg_selected=$( lui_list_key_move_selection "${key_args[@]}" ); then
                proc_args=( "$keyp" "$term_keys_list_name" "$lui_list_name" "$llg_selected" )
                lui_list_process_key "${proc_args[@]}" "${extra_args[@]}"
                key_proc_exit="$?"
                if [ "$key_proc_exit" -gt 1 ]; then
                    return 0
                elif [ "$key_proc_exit" -gt 0 ]; then
                    return 1
                fi
            fi
        fi
    done
}

lui_list_menu()
{
    local -n llm_selected="$1"
    local lui_list_name="$2"
    local line_displayer="${3:-lui_list_display_line}"
    local -i line_count="${4:-10}"

    if [ ! "$llm_selected" ]; then
        llm_selected=0
    fi
    local -i old_selected=$llm_selected

    local -i row_count
    lui_list_row_count "row_count" "$lui_list_name"

    local -i top_row padding
    padding=$( lui_list_max_len_by_column "$lui_list_name" 0 )

    local keyp

    top_row=1
    while : ; do
        top_row=$( lui_list_calc_top_row "$llm_selected" "$top_row" "$line_count" )

        reset_screen
        hide_cursor
        lui_list_show_lines "$lui_list_name" "$llm_selected" "$top_row" \
                             "$line_count" "$line_displayer" "$padding"
        show_cursor


        if get_keypress "keyp"; then
            case "$keyp" in
                $'\e'|'q' )
                    lim_selected="$old_selected"
                    return 1
                    ;;
                $'\n' )
                    return 0
                    ;;
                * )
                    llm_selected=$( lui_list_key_move_selection \
                                        "$keyp" \
                                        "$llm_selected" \
                                        "$top_row" \
                                        "$line_count" \
                                        "$row_count")
                    ;;
            esac
        fi
    done
}

