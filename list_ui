#!/usr/bin/env bash

# The contents of this file work with a _lui_list_.  A lui_list is
# an array of data organized as a mini table.  The first element of
# a lui_list is the column count, the number of elements per 'row'
# of the lui_list table.  The second element is the row count, and
# it should be set with the lui_list_init() function.

# shellcheck disable=SC2178
# shellcheck disable=SC2034   # disable unused variable warning for nameref variable _rc_

declare LUI_KEY_UP=$'\e[A'
declare LUI_KEY_DN=$'\e[B'
declare LUI_KEY_PGUP=$'\e[5~'
declare LUI_KEY_PGDN=$'\e[6~'

LUI_ABORT()  { return 1; }
LUI_SELECT() { return 2; }

declare -a LUI_DEFAULT_TERM_KEYS=(
    $'\e'"|q:LUI_ABORT"
    $'\n'":LUI_SELECT"
    )

# Sets the row-count element (list[1]) by calculating the number
# of rows.  A suspicious element count (not evenly-dividable by
# the column count) triggers a warning and exit.
# Args
#    (string):   name of a properly formatted list
lui_list_init()
{
    local -n luii_list="$1"
    local -i columns="${luii_list[0]}"

    local -i count_els="${#luii_list[@]}"
    if [ $(( (count_els - 2) % columns )) -ne 0 ]; then
        echo "corrupted list, bad elements ratio." >&2
        read -n1
        exit
    fi

    luii_list[1]=$(( ( count_els - 2 ) / columns ))
    return 0
}

lui_list_convert()
{
    if [ "$1" == "$2" ]; then
        echo "Input and output lists must be different." >&2
        exit 1
    fi

    local -n llc_list_out="$1"
    local -n llc_list_in="$2"
    local -i in_cols="$3"
    local -i out_cols="$4"

    local -a extra_cols=()

    if [ "$out_cols" -gt "$in_cols" ]; then
        for (( i=0, limit=out_cols-in_cols; i<limit; ++i )); do
            extra_cols+=( 0 )
        done
    else
        out_cols="$in_cols"
    fi

    llc_list_out=( "$out_cols" 0 )
    local el
    local -a row=()
    local -i count=0
    for el in "${llc_list_in[@]}"; do
        row+=( "$el" )
        if [ "${#row[@]}" -eq "${in_cols}" ]; then
            (( ++count ))
            llc_list_out+=( "${row[@]}" "${extra_cols[@]}" )
            row=()
        fi
    done

    llc_list_out[1]="$count"
}

# Next two functions put result in nameref-ed first argument
lui_list_column_count() { local -n rc="$1"; local -n luil_list="$2"; rc="${luil_list[0]}"; }
lui_list_row_count()    { local -n rc="$1"; local -n luil_list="$2"; rc="${luil_list[1]}"; }

# Test if requested row number exists in a lui_list
# Args
#    (string):   name of lui list
#    (integer):  row number requested
#
# Returns true (0) if in range, non-zero if out of range
lui_list_row_in_range()
{
    local -n luii_list="$1"
    local -i requested_row="$2"
    local -i rows="${luii_list[1]}"

    [ "$requested_row" -ge 0 ] && [ "$requested_row" -lt "$rows" ]
}

# Sends successive rows to a callback function.  The callback function
# should return 0 (true) to continue, false (non-zero) to force early
# termination.
# 
# Args
#    (string):   name of lui_list array
#    (string):   name of callback function
lui_list_iterate()
{
    local -i rows columns
    lui_list_row_count "rows" "$1"
    lui_list_column_count "columns" "$1"

    local -n luili_list="$1"
    local luili_callback="$2"

    for (( ndx=2, row=0; row<rows; ++row, ndx+=columns )); do
        if ! "$luili_callback" "${luili_list[@]:$ndx:$columns}"; then
            break
        fi
    done
}

# Get a row from a lui_list array.  Returns 0 (true) if the row
# was successfully returned, non-zero (false) if out-of-range and
# no row data is being returned.
# Args
#    (string):   name of array in which the row is to be copied
#    (string):   name of lui_list array
#    (integer):  row number to be returned
lui_list_copy_row()
{
    if lui_list_row_in_range "$2" "$3"; then
        local -n target_row="$1"
        local -n luii_list="$2"
        local -i requested_row="$3"

        local -i columns="${luii_list[0]}"
        local -i rows="${luii_list[1]}"

        local -i ndx=$(( 2 + ( requested_row * columns ) ))
        target_row=( "${luii_list[@]:$ndx:$columns}" )
        return 0
    else
        echo "requested_row $3 is an out-of-range value for list '$2'" >&2
    fi

    return 1
}

# Get a row from a lui_list array.  Returns 0 (true) if the row
# was successfully returned, non-zero (false) if out-of-range and
# no row data is being returned.
# Args
#    (string):   name of lui_list array
#    (string):   name of array from which the row is to be copied
#    (integer):  row number to be replaced
lui_list_replace_row()
{
    local list_name="$1"
    local -n luii_list="$list_name"
    local -n source_row="$2"
    local -i target_row_num="$3"

    if lui_list_row_in_range "$1" "$3"; then
        local -i columns="${luii_list[0]}"
        local -i rows="${luii_list[1]}"

        local -i ndx=$(( 2 + ( target_row_num * columns ) ))
        for (( i=0; i<columns; ++i )); do
            luii_list[$(( ndx + i ))]="${source_row[$i]}"
        done
        return 0
    else
        echo "requested_row $3 is an out-of-range value for list '$2'" >&2
    fi

    return 1
}

# Clumsy name for a function that returns the characters in the longest
# string in the given column for the given lui_list.
# Args
#    (string):  name of lui_list array
#    (integer): 0-based column number of column of interest
lui_list_max_len_by_column()
{
    local -i maxlen=0
    local -i requested_column="$2"
    max_len_callback()
    {
        # shellcheck disable=SC2124
        local val="${@:$(( requested_column+1 )):1}"
        local -i len="${#val}"
        if [ "$len" -gt "$maxlen" ]; then
            maxlen="$len"
        fi
    }

    lui_list_iterate "$1" "max_len_callback"
    unset max_len_callback

    echo "$maxlen"
}

lui_list_menu_display_line()
{
    local -i hilite="$1"
    local -i padding="$2"
    local -a els=( "${@:3}" )

    if [ "$hilite" -ne 0 ]; then
        echo -n $'\e[44m'
    fi
    hilite_pad "${els[0]}" "$padding"
    echo $'\e[m'
}

lui_list_key_move_selection()
{
    local keyp="$1"
    local -i selected="$2"
    local -i top_row="$3"
    local -i line_count="$4"
    local -i row_count="$5"

    local -i bottom_row=$(( top_row + line_count - 1 ))
    local -i matched=0

    case "$keyp" in
        "$LUI_KEY_DN" )
            (( ++selected, ++matched ))
            if [ "$selected" -ge "$row_count"  ]; then
                selected=$(( row_count-1 ))
            fi
            ;;
        "$LUI_KEY_UP" )
            (( --selected, ++matched ))
            if [ "$selected" -lt 0 ]; then
                selected=0
            fi
            ;;
        "$LUI_KEY_PGUP" )
            (( ++matched ))
            if [ "$selected" -eq "$top_row" ]; then
                selected=$(( selected - line_count ))
            else
                selected="$top_row"
            fi
            if [ "$selected" -lt 0 ]; then
                selected=0
            fi
            ;;
        "$LUI_KEY_PGDN" )
            (( ++matched ))
            if [ "$selected" -eq "$bottom_row" ]; then
                selected=$(( selected + line_count ))
            else
                selected="$bottom_row"
            fi
            if [ "$selected" -ge "$row_count" ]; then
                selected=$(( row_count - 1 ))
            fi
            ;;
    esac

    echo "$selected"
    [ "$matched" -gt 0 ]
}

lui_list_calc_top_row()
{
    local -i selected="$1"
    local -i top_row="$2"
    local -i line_count="$3"
    if [ "$selected" -lt "$top_row" ]; then
        echo "$selected"
    elif [ "$selected" -gt $(( top_row + line_count - 1 )) ]; then
        echo $(( selected - line_count + 1 ))
    else
        echo "$top_row"
    fi
}

lui_list_show_lines()
{
    local lui_list_name="$1"
    local -i selected="$2"
    local -i top_row="$3"
    local -i line_count="$4"
    local line_displayer="$5"
    local -i padding="${6:-0}"

    local -a row
    local -i count=0
    local -i row_ndx="$top_row"
    local -i hilited

    for (( ; count < line_count; ++count, ++row_ndx )); do
        row=()
        if [ "$row_ndx" -lt "$row_count" ]; then

            # Convert boolean result to integer for use by line_displayer:
            [ "$row_ndx" -ne "$selected" ]
            hilited="$?"

            lui_list_copy_row "row" "$lui_list_name" "$row_ndx"
            "$line_displayer" "$hilited" "$padding" "${row[@]}"
        else
            hilite_pad " " "$padding"
            echo
        fi
    done
}



lui_list_process_key()
{
    local keyp="$1"
    local -n key_arr="$2"
    local list_name="$3"
    local -i row_number="$4"

    local -a entry keys
    local k IFS key cmd
    for k in "${key_arr[@]}"; do
        IFS=':'; entry=( $k )
        IFS="|"; keys=( ${entry[0]} )
        cmd="${entry[1]}"

        for key in "${keys[@]}"; do
            if [ "$key" == "$keyp" ]; then
                "$cmd" "$keyp" "$list_name" "$row_number"
                return "$?"
            fi
        done
    done

    # zero return value means that we didn't match the key
    return 0
}

lui_list_generic()
{
    local -n llg_selected="$1"
    local lui_list_name="$2"
    local line_displayer="${3:-lui_list_menu_display_line}"
    local -i line_count="${4:-10}"

    local term_keys_list_name="${5:-LUI_DEFAULT_TERM_KEYS}"
    local exec_keys_list_name="$6"

    local -i row_count
    lui_list_row_count "row_count" "$lui_list_name"

    local -i padding=$( lui_list_max_len_by_column "$lui_list_name" 0 )

    local -i top_row
    local -a row
    local -a key_args proc_args
    local keyp
    local -i key_proc_exit

    top_row=1
    while : ; do
        top_row=$( lui_list_calc_top_row "$llg_selected" "$top_row" "$line_count" )

        reset_screen
        hide_cursor
        lui_list_show_lines "$lui_list_name" "$llg_selected" "$top_row" \
                             "$line_count" "$line_displayer" "$padding"
        show_cursor

        if get_keypress "keyp"; then
            key_args=( "$keyp" "$llg_selected" "$top_row" "$line_count" "$row_count" )
            if ! llg_selected=$( lui_list_key_move_selection "${key_args[@]}" ); then
                proc_args=( "$keyp" "$term_keys_list_name" "$lui_list_name" "$llg_selected" )
                lui_list_process_key "${proc_args[@]}"
                key_proc_exit="$?"
                if [ "$key_proc_exit" -gt 1 ]; then
                    return 0
                elif [ "$key_proc_exit" -gt 0 ]; then
                    return 1
                fi
            fi
        fi
    done
}

lui_list_menu()
{
    local -n llm_selected="$1"
    local lui_list_name="$2"
    local line_displayer="${3:-lui_list_menu_display_line}"
    local -i line_count="${4:-10}"

    if [ ! "$llm_selected" ]; then
        llm_selected=0
    fi
    local -i old_selected=$llm_selected

    local -i row_count
    lui_list_row_count "row_count" "$lui_list_name"

    local -i padding=$( lui_list_max_len_by_column "$lui_list_name" 0 )
    local -i top_row

    local keyp

    top_row=1
    while : ; do
        top_row=$( lui_list_calc_top_row "$llm_selected" "$top_row" "$line_count" )

        reset_screen
        hide_cursor
        lui_list_show_lines "$lui_list_name" "$llm_selected" "$top_row" \
                             "$line_count" "$line_displayer" "$padding"
        show_cursor


        if get_keypress "keyp"; then
            case "$keyp" in
                $'\e'|'q' )
                    lim_selected="$old_selected"
                    return 1
                    ;;
                $'\n' )
                    return 0
                    ;;
                * )
                    llm_selected=$( lui_list_key_move_selection \
                                        "$keyp" \
                                        "$llm_selected" \
                                        "$top_row" \
                                        "$line_count" \
                                        "$row_count")
                    ;;
            esac
        fi
    done
}

