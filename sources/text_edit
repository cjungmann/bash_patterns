# -*- mode: sh; sh-shell: bash -*-
# shellcheck disable=SC2148    # #! not appropriate for sourced script, using mode instead

# needs small_stuff, keypress

edit_text_dialog()
{
    local value_name="$1"
    local -n etd_value="$1"
    local -i limit="$2"
    local prompt="${3:-Edit the value}"

    local -i margin=2
    local -i prompt_len="${#prompt}"

    local -i row=0 col=0 rows=5 cols=$(( limit + margin ))
    get_block_centering_values row col rows cols
    draw_box "$row" "$col" "$rows" "$cols"

    local -i center_col=$(( cols/2 + col ))
    local -i prompt_col=$(( center_col - (prompt_len/2) ))

    local -i trow=$(( row + 1 ))
    local -i tcol=$(( col + 1 ))
    set_cursor_position "$trow" "$prompt_col"
    echo "${prompt}"
    set_cursor_position $(( ++trow )) "$tcol"

    edit_text "$value_name" "$limit"
    local -i retval="$?"

    block_erase "$row" "$col" "$rows" "$cols"
}


edit_text()
{
   local -n et_strvalue="$1"
   local -i length="$2"

   local COLON=$'\e[48;5;238m'
   local COLOFF=$'\e[m'

   local empty=$( dupchar "$length" ' ' )

   # status variables
   local keyp
   local -i keyp_len strlen
   local str="$et_strvalue"
   local -i keyval
   local -i retval=2

   # Will frequently return to starting position
   local -i row col
   get_cursor_position "row" "col"

   # Prepare and display entry area
   echo -n "${COLON}"
   echo -n "$empty"
   set_cursor_position "$row" "$col"
   echo -n "$str"
   show_cursor

   while :; do
       if get_keypress "keyp"; then
           keyp_len="${#keyp}"
           if [ "$keyp" == $'\e' ]; then
               retval=1
               break
           elif [ "$keyp" == $'\n' ]; then
               retval=0
               et_strvalue="$str"
               break
           elif [ "$keyp_len" -eq 1 ]; then
               keyval=$( val_from_char "$keyp" )
               if [ "$keyval" == 127 ]; then
                   # fix value
                   strlen="${#str}"
                   str="${str:0:$(( strlen-1 ))}"
                   # fix display
                   echo -n $'\e[1D \e[1D'
               elif [ "$keyval" -ge 32 ]; then
                   str="${str}$keyp"
                   echo -n "$keyp"
               fi
           fi
           # ignore mult-char keystrokes for new
       fi
   done

   hide_cursor
   echo "$COLOFF"

   return "$retval"
}
